.\" Copyright (C) 2019 VirtualSquare. Project Leader: Renzo Davoli
.\"
.\" This is free documentation; you can redistribute it and/or
.\" modify it under the terms of the GNU General Public License,
.\" as published by the Free Software Foundation, either version 2
.\" of the License, or (at your option) any later version.
.\"
.\" The GNU General Public License's references to "object code"
.\" and "executables" are to be interpreted as the output of any
.\" document formatting or typesetting system, including
.\" intermediate and printed output.
.\"
.\" This manual is distributed in the hope that it will be useful,
.\" but WITHOUT ANY WARRANTY; without even the implied warranty of
.\" MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.\" GNU General Public License for more details.
.\"
.\" You should have received a copy of the GNU General Public
.\" License along with this manual; if not, write to the Free
.\" Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,
.\" MA 02110-1301 USA.
.\"
.\" Automatically generated by Pandoc 2.17.1.1
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "FDUSERDATA" "3" "December 2022" "VirtualSquare" "Library Functions Manual"
.hy
.SH NAME
.PP
fduserdata_create, fduserdata_destroy, fduserdata_destroy_cb,
fduserdata_new, fduserdata_get, fduserdata_put, fduserdata_del -
associate file descriptors with user defined data
.SH SYNOPSIS
.PP
\f[V]#include *fduserdata.h*\f[R]
.PP
\f[V]FDUSERDATA *fduserdata_create(int\f[R] \f[I]size\f[R]\f[V]);\f[R]
.PP
\f[V]void fduserdata_destroy(FDUSERDATA *\f[R]\f[I]fdtable\f[R]\f[V]);\f[R]
.PP
\f[V]typedef void (*fduserdata_destr_cb_t)(int fd, void *data, void *arg);\f[R]
\f[I]br/\f[R]
\f[V]void fduserdata_destroy_cb(FDUSERDATA *\f[R]\f[I]fdtable\f[R]\f[V], fduserdata_destr_cb_t\f[R]
\f[I]callback\f[R]\f[V], void *\f[R]\f[I]arg\f[R]\f[V]);\f[R]
.PP
\f[V]void *fduserdata_new(FDUSERDATA *\f[R]\f[I]fdtable\f[R]\f[V], int\f[R]
\f[I]fd\f[R]\f[V],\f[R] \f[I]type\f[R]\f[V]);\f[R]
.PP
\f[V]void *fduserdata_get(FDUSERDATA *\f[R]\f[I]fdtable\f[R]\f[V], int\f[R]
\f[I]fd\f[R]\f[V]);\f[R]
.PP
\f[V]void fduserdata_put(void *\f[R]\f[I]data\f[R]\f[V]);\f[R]
.PP
\f[V]int fduserdata_del(void *\f[R]\f[I]data\f[R]\f[V]);\f[R]
.SH DESCRIPTION
.PP
This library permits one to associate file descriptors with user defined
data, more precisely it manages a data structure whose searching key is
a file descriptor.
.PP
\f[V]fduserdata_create\f[R] and \f[V]fduserdata_destroy\f[R] are the
constructor and destructor of the data structure, respectively.
The data structure has been implemented as a hash table, the argument
\f[I]size\f[R] of \f[V]fduserdata_create\f[R] is the size of the hash
array.
When \f[I]size\f[R] is zero the hash array has its default size (64).
.PP
\f[V]fduserdata_destroy_cb\f[R] is an alternative destructor which calls
the function \f[I]callback\f[R] for each element still in the data
structure.
.PP
\f[V]fduserdata_new\f[R] creates a new element.
It is a macro: \f[I]type\f[R] is the type of the user data.
.PP
\f[V]fduserdata_get\f[R] search the user data associated to the
\f[I]fd\f[R].
.PP
Both \f[V]fduserdata_new\f[R] and \f[V]fduserdata_get\f[R] lock the
access to the element, so that fduserdata is thread safe.
\f[V]fduserdata_put\f[R] unlocks the element and makes it available for
further requests.
.PP
\f[V]fduserdata_del\f[R] can be used instead of \f[V]fduserdata_put\f[R]
to delete the element.
.SH RETURN VALUE
.PP
\f[V]fduserdata_create\f[R] returns the descriptor of the data structure
(NULL in case of error).
.PP
\f[V]fduserdata_new\f[R] returns the element of type \f[I]type\f[R] just
created (NULL in case of error).
.PP
\f[V]fduserdata_get\f[R] returns the element or NULL if no data
corresponds to the file descriptor \f[I]fd\f[R].
.PP
\f[V]fduserdata_del\f[R] On success, zero is returned.
On error, -1 is returned.
.PP
On error, \f[I]errno\f[R] is set appropriately.
.SH EXAMPLE
.PP
fduserdata uses a trivial hash table, the optional arg is the size of
the hash table: default value = 64
.IP
.nf
\f[C]
  FDUSERDATA table = fduserdata_create(0);

  struct mydata {
  // fd data fields ...
     };
\f[R]
.fi
.PP
create a struct mydata for the file descriptor fd.
.IP
.nf
\f[C]
  struct mydata *data = fduserdata_new(table, fd, struct mydata);
\f[R]
.fi
.PP
\&....
set user defined data (data-*fields)
.IP
.nf
\f[C]
  fduserdata_put(data);
\f[R]
.fi
.PP
search for data there is mutual exclusion between new/put, get/put (or
new/del, get/del) so do not insert time consuming or blocking ops.
.IP
.nf
\f[C]
  struct mydata *fddata = fduserdata_get(table, fd);
  if (fddata) {
\f[R]
.fi
.PP
\&...
read/update user defined data (data->fields) (use fduserdata_del instead
of fduserdata_put to delete the element)
.IP
.nf
\f[C]
      fduserdata_put(data);
  }
\f[R]
.fi
.PP
at the end\&...
when table is no longer required
.IP
.nf
\f[C]
  fduserdata_destroy(table);
\f[R]
.fi
.SH AUTHOR
.PP
VirtualSquare.
Project leader: Renzo Davoli.
